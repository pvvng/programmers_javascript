const n = 4

/** DP / 해결 방법 => 점화식 / 기본값 설정하기 */
// 7~ 실패
function solution(n) {
    /** 
     * <f(n)은 n칸에 올 수 있는 모든 경우의 수>
     * 
     * 마지막 점프를 1칸 한 경우
     * n-1 칸의 방법 수에 1칸 추가
     * 
     * 마지막 점프를 2칸 한 경우
     * n-2 칸의 방법 수에 2칸 추가
     * 
     * 고로 점화식은 
     * f(n) = f(n-1) + f(n-2)
     * 
     * 예시)
     * f(1) = 1
     * f(2) = 2
     * f(3) = ???
     * 마지막에 한칸 점프했을 경우: 2칸 이동의 경우의 수를 파악
     * 마지막에 두칸 점프했을 경우: 1칸 이동의 경우의 수를 파악
     * 즉, f(3) = f(2) + f(1)
     */
    /**
     * DP 해결 단계
     * 1. 기본 값 설정 (이 문제에서는 f(1) = 1, f(2) = 2)
     * 2. 배열 생성 (f(n)의 값을 저장할 배열이나 변수를 만든다.)
     * 3. 점화식 반복 적용
     * 4. 결과 반환
     */
    // 기본값 설정 (f(0), f(1), f(2))
    let resultArr = [0, 1, 2];
    // i = 3 (기본값 이상인 최소 자연수) 부터 n이 될때까지 1씩 증가시키기
    for(let i = 3; i <= n; i++){
        /** f(n) = value에 overflow 발생하는 경우를 막기 위해 
         * 결과값을 미리 1234567로 만들기
         *  */
        let fnv = (resultArr[i-1] + resultArr[i-2]) % 1234567;
        resultArr.push(fnv);
    }
    return resultArr[n] % 1234567;
}

solution(n);

// node LV2/멀리뛰기.js